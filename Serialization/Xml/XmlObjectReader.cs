#region License
// Copyright (c) 2014, David Taylor
//
// Permission to use, copy, modify, and/or distribute this software for any 
// purpose with or without fee is hereby granted, provided that the above 
// copyright notice and this permission notice appear in all copies, unless 
// such copies are solely in the form of machine-executable object code 
// generated by a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES 
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF 
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR 
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES 
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#endregion License
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Xml;

namespace HotChai.Serialization.Xml
{
    public sealed class XmlObjectReader : ObjectReader
    {
        private XmlReader _reader;
        private readonly InspectorStream _stream;
        private bool _peeking;

        public XmlObjectReader(
            Stream stream)
        {
            if (null == stream)
            {
                throw new ArgumentNullException("stream");
            }

            this._stream = new InspectorStream(stream);
        }

        public override ISerializationInspector Inspector
        {
            get { return this._stream.Inspector; }

            set { this._stream.Inspector = value; }
        }

        private XmlReader Reader
        {
            get
            {
                if (null == this._reader)
                {
                    // NOTE: XmlReader reads from the underlying stream on initialization,
                    // before the Inspector property can be set. So, it must be lazily created.
                    // NOTE: XmlReader also reads from the stream in chunks, so it will read
                    // past the last byte of a serialized object in a stream and break 
                    // ISerializationInspector as well as prevent a new instance of XmlObjectReader 
                    // from deserializing another object from the same stream.
                    // CONSIDER: Switch to BinaryReader.
                    this._reader = XmlReader.Create(
                        this._stream,
                        new XmlReaderSettings()
                        {
                            ConformanceLevel = ConformanceLevel.Fragment,
                            CheckCharacters = false,
                        });
                }

                return this._reader;
            }
        }

        protected override bool ReadStartObjectToken()
        {
            ReadStartElement();

            if ((this.Reader.Name == XmlToken.ObjectElement) && (this.Reader.IsStartElement()))
            {
                return true;
            }
            else if ((this.Reader.Name == XmlToken.NullElement) && (this.Reader.IsEmptyElement))
            {
                return false;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        protected override bool ReadFirstObjectMemberKey()
        {
            if ((this.Reader.Name == XmlToken.ObjectElement)
                && (this.Reader.IsEmptyElement))
            {
                return false;
            }

            Peek();

            if (this.Reader.Name == XmlToken.ObjectElement)
            {
                return false;
            }

            ReadStartElement();

            if (this.Reader.Name != XmlToken.MemberElement)
            {
                throw new InvalidOperationException();
            }

            string memberName = this.Reader.GetAttribute(XmlToken.MemberKeyAttribute);

            this.MemberKey = int.Parse(memberName, CultureInfo.InvariantCulture);

            return true;
        }

        protected override bool ReadNextObjectMemberKey()
        {
            this.ReadStartElement();

            if ((this.Reader.Name != XmlToken.MemberElement) || (this.Reader.IsStartElement()))
            {
                throw new InvalidOperationException();
            }

            return ReadFirstObjectMemberKey();
        }

        protected override void ReadEndObjectToken()
        {
            if ((this.Reader.Name == XmlToken.ObjectElement)
                && (this.Reader.IsEmptyElement))
            {
                return;
            }

            ReadPeekedEndElement(XmlToken.ObjectElement);
        }

        protected override bool ReadStartArrayToken()
        {
            ReadStartElement();

            if (this.Reader.Name == XmlToken.ArrayElement)
            {
                return true;
            }
            else if (this.Reader.Name == XmlToken.NullElement)
            {
                return false;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        protected override bool ReadToFirstArrayValue()
        {
            if ((this.Reader.Name == XmlToken.ArrayElement)
                && (this.Reader.IsEmptyElement))
            {
                // Empty array (<array />)
                return false;
            }

            return ReadToNextArrayValue();
        }

        protected override bool ReadToNextArrayValue()
        {
            Peek();

            if ((this.Reader.Name == XmlToken.ArrayElement)
                && (this.Reader.NodeType == XmlNodeType.EndElement))
            {
                return false;
            }

            if ((this.Reader.Name == XmlToken.NullElement)
                && (this.Reader.IsEmptyElement))
            {
                return true;
            }

            if ((this.Reader.Name != XmlToken.ValueElement)
                && (this.Reader.Name != XmlToken.ObjectElement)
                && (this.Reader.Name != XmlToken.ArrayElement))
            {
                throw new InvalidOperationException();
            }

            return true;
        }

        protected override void ReadEndArrayToken()
        {
            if ((this.Reader.Name == XmlToken.ArrayElement)
                && (this.Reader.IsEmptyElement))
            {
                // Empty array (<array />)
                return;
            }

            ReadPeekedEndElement(XmlToken.ArrayElement);
        }

        protected override bool ReadPrimitiveValueAsBoolean()
        {
            string valueContent = ReadPrimitiveValueAsString(1);

            if (valueContent == "1")
            {
                return true;
            }
            else if (valueContent == "0")
            {
                return false;
            }
            else
            {
                throw new InvalidOperationException("Unexpected Boolean value.");
            }
        }

        protected override int ReadPrimitiveValueAsInt32()
        {
            string valueContent = ReadPrimitiveValueAsString(25);

            return int.Parse(valueContent, CultureInfo.InvariantCulture);
        }

        protected override uint ReadPrimitiveValueAsUInt32()
        {
            string valueContent = ReadPrimitiveValueAsString(25);

            return uint.Parse(valueContent, CultureInfo.InvariantCulture);
        }

        protected override long ReadPrimitiveValueAsInt64()
        {
            string valueContent = ReadPrimitiveValueAsString(50);

            return long.Parse(valueContent, CultureInfo.InvariantCulture);
        }

        protected override ulong ReadPrimitiveValueAsUInt64()
        {
            string valueContent = ReadPrimitiveValueAsString(50);

            return ulong.Parse(valueContent, CultureInfo.InvariantCulture);
        }

        protected override float ReadPrimitiveValueAsSingle()
        {
            string valueContent = ReadPrimitiveValueAsString(25);

            return float.Parse(valueContent, CultureInfo.InvariantCulture);
        }

        protected override double ReadPrimitiveValueAsDouble()
        {
            string valueContent = ReadPrimitiveValueAsString(25);

            return double.Parse(valueContent, CultureInfo.InvariantCulture);
        }

        protected override byte[] ReadPrimitiveValueAsBytes(int quota)
        {
            // TODO: Consider CDATA

            // NOTE: Account for base-64 length expansion
            string valueContent = ReadPrimitiveValueAsString(quota * 4 / 3 + 1);
            if (null == valueContent)
            {
                return null;
            }

            return Convert.FromBase64String(valueContent);
        }

        protected override string ReadPrimitiveValueAsString(int quota)
        {
            ReadStartElement();

            if (this.Reader.Name == XmlToken.NullElement)
            {
                ReadPeekedEndElement(XmlToken.NullElement);

                //this.Reader.Read();

                return null;
            }

            if (this.Reader.Name != XmlToken.ValueElement)
            {
                throw new InvalidOperationException();
            }

            string value;
            if (this.Reader.IsEmptyElement)
            {
                value = String.Empty;
            }
            else
            {
                this.Reader.Read();
                value = this.Reader.ReadContentAsString();
            }

            if ((this.Reader.Name != XmlToken.ValueElement)
                || ((this.Reader.NodeType != XmlNodeType.EndElement) && (!this.Reader.IsEmptyElement)))
            {
                throw new InvalidOperationException();
            }

            return value;
        }

        protected override MemberValueType PeekValueType()
        {
            Peek();

            if (this.Reader.Name == XmlToken.ObjectElement)
            {
                return MemberValueType.Object;
            }
            else if (this.Reader.Name == XmlToken.ArrayElement)
            {
                return MemberValueType.Array;
            }

            return MemberValueType.Primitive;
        }

        protected override void SkipPrimitiveValue()
        {
            // Expect to be on "value" or "null" start element
            if ((this.Reader.Name != XmlToken.ValueElement)
                && (this.Reader.Name != XmlToken.NullElement))
            {
                throw new InvalidOperationException();
            }

            if (this._peeking)
            {
                this._peeking = false;
            }

            if (this.Reader.Name == XmlToken.NullElement)
            {
                // Expect to be an end element (<null />)
                if (!this.Reader.IsEmptyElement)
                {
                    throw new InvalidOperationException();
                }
            }
            else if (this.Reader.Name == XmlToken.ValueElement)
            {
                if (!this.Reader.IsEmptyElement)
                {
                    ReadStartElement();

                    // Check for an empty value element
                    if (this.Reader.Name == XmlToken.ValueElement)
                    {
                        // Expect to be an end element (</value>)
                        if (this.Reader.NodeType != XmlNodeType.EndElement)
                        {
                            throw new InvalidOperationException();
                        }
                    }
                    else
                    {
                        // Check for expected value content
                        if ((this.Reader.NodeType != XmlNodeType.Text)
                            && (this.Reader.Name != XmlToken.ObjectElement)
                            && (this.Reader.Name != XmlToken.ArrayElement))
                        {
                            // Unexpected nested value
                            throw new InvalidOperationException();
                        }

                        this.Reader.Skip();

                        if ((this.Reader.Name != XmlToken.ValueElement)
                            || (this.Reader.NodeType != XmlNodeType.EndElement))
                        {
                            throw new InvalidOperationException();
                        }
                    }
                }
            }
            else
            {
                // Unexpected element (expected <value> or <null>)
                throw new InvalidOperationException();
            }
        }

        private void Peek()
        {
            if (this._peeking)
            {
                return;
            }

            this.Reader.Read();

            this._peeking = true;
        }

        private void ReadStartElement()
        {
            if (this._peeking)
            {
                if (!this.Reader.IsStartElement())
                {
                    throw new InvalidOperationException();
                }

                this._peeking = false;
                return;
            }

            this.Reader.Read();

            //if (!this.Reader.IsStartElement())
            //{
            //    throw new InvalidOperationException();
            //}
        }

        private void ReadPeekedEndElement(
            string name)
        {
            if (this._peeking)
            {
                if (this.Reader.IsStartElement())
                {
                    throw new InvalidOperationException();
                }

                if (this.Reader.Name != name)
                {
                    throw new InvalidOperationException("Unexpected element name.");
                }

                this._peeking = false;
                return;
            }
        }
    }
}
