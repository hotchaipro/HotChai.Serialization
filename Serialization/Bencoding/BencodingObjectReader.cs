#region License
// Copyright (c) 2014, David Taylor
//
// Permission to use, copy, modify, and/or distribute this software for any 
// purpose with or without fee is hereby granted, provided that the above 
// copyright notice and this permission notice appear in all copies, unless 
// such copies are solely in the form of machine-executable object code 
// generated by a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES 
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF 
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR 
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES 
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#endregion License
using System;
using System.Globalization;
using System.IO;
using System.Text;

namespace HotChai.Serialization.Bencoding
{
    public sealed class BencodingObjectReader : ObjectReader
    {
        private readonly InspectorStream _stream;
        private readonly BinaryReader _reader;
        private char _peekChar;
        private bool _peeking;

        public BencodingObjectReader(
            Stream stream)
        {
            if (null == stream)
            {
                throw new ArgumentNullException("stream");
            }

            this._stream = new InspectorStream(stream);
            this._reader = new BinaryReader(this._stream, Encoding.UTF8);
        }

        public override ISerializationInspector Inspector
        {
            get
            {
                return this._stream.Inspector;
            }

            set
            {
                this._stream.Inspector = value;
            }
        }

        protected override bool ReadStartObjectToken()
        {
            char token = ReadToken();
            if (token == BencodingToken.Dictionary)
            {
                return true;
            }
            else if (token == BencodingToken.Null)
            {
                return false;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        protected override bool ReadNextObjectMemberKey()
        {
            // Read the next token
            char token = PeekToken();

            // Check for an end object token
            if (token == BencodingToken.End)
            {
                return false;
            }

            // Set the current object member key
            // NOTE: The official bencoding specification only allows 
            // string keys in dictionary encodings.
            string memberKeyString = ReadPrimitiveValueAsString(15);
            this.MemberKey = Int32.Parse(memberKeyString);

            return true;
        }

        protected override void ReadEndObjectToken()
        {
            char token = ReadToken();
            if (token != BencodingToken.End)
            {
                throw new InvalidOperationException();
            }
        }

        protected override bool ReadStartArrayToken()
        {
            char token = ReadToken();
            if (token == BencodingToken.List)
            {
                return true;
            }
            else if (token == BencodingToken.Null)
            {
                return false;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        protected override bool ReadToNextArrayValue()
        {
            char token = PeekToken();
            if (token == BencodingToken.End)
            {
                return false;
            }

            return true;
        }

        protected override void ReadEndArrayToken()
        {
            char token = ReadToken();
            if (token != BencodingToken.End)
            {
                throw new InvalidOperationException();
            }
        }

        protected override bool ReadPrimitiveValueAsBoolean()
        {
            bool value;

            char token = ReadToken();
            if (token != BencodingToken.Integer)
            {
                throw new InvalidOperationException();
            }

            token = ReadToken();
            if (token == '0')
            {
                value = false;
            }
            else if (token == '1')
            {
                value = true;
            }
            else
            {
                throw new InvalidOperationException("Unexpected Boolean value.");
            }

            token = ReadToken();
            if (token != BencodingToken.End)
            {
                throw new InvalidOperationException();
            }

            return value;
        }

        protected override int ReadPrimitiveValueAsInt32()
        {
            char token = ReadToken();
            if (token != BencodingToken.Integer)
            {
                throw new InvalidOperationException();
            }

            int value = 0;
            int sign = 1;
            do
            {
                token = ReadToken();
                if (token == BencodingToken.End)
                {
                    break;
                }
                else if (token == '-')
                {
                    sign = -1;
                    continue;
                }

                value = (10 * value) + (token - '0'); 
            }
            while (true);

            if (sign > 0)
            {
                return value;
            }
            else
            {
                return -value;
            }
        }

        protected override uint ReadPrimitiveValueAsUInt32()
        {
            char token = ReadToken();
            if (token != BencodingToken.Integer)
            {
                throw new InvalidOperationException();
            }

            uint value = 0;
            do
            {
                token = ReadToken();
                if (token == BencodingToken.End)
                {
                    break;
                }

                value = (10 * value) + (uint)(token - '0');
            }
            while (true);

            return value;
        }

        protected override long ReadPrimitiveValueAsInt64()
        {
            char token = ReadToken();
            if (token != BencodingToken.Integer)
            {
                throw new InvalidOperationException();
            }

            long value = 0;
            int sign = 1;
            do
            {
                token = ReadToken();
                if (token == BencodingToken.End)
                {
                    break;
                }
                else if (token == '-')
                {
                    sign = -1;
                    continue;
                }

                value = (10 * value) + (token - '0');
            }
            while (true);

            if (sign > 0)
            {
                return value;
            }
            else
            {
                return -value;
            }
        }

        protected override ulong ReadPrimitiveValueAsUInt64()
        {
            char token = ReadToken();
            if (token != BencodingToken.Integer)
            {
                throw new InvalidOperationException();
            }

            ulong value = 0;
            do
            {
                token = ReadToken();
                if (token == BencodingToken.End)
                {
                    break;
                }

                value = (10 * value) + (uint)(token - '0');
            }
            while (true);

            return value;
        }

        protected override float ReadPrimitiveValueAsSingle()
        {
            string stringValue = ReadPrimitiveValueAsString(15);

            return float.Parse(stringValue);
        }

        protected override double ReadPrimitiveValueAsDouble()
        {
            string stringValue = ReadPrimitiveValueAsString(30);

            return double.Parse(stringValue);
        }

        protected override byte[] ReadPrimitiveValueAsBytes(
            int quota)
        {
            char token = ReadToken();
            if (token == BencodingToken.Null)
            {
                return null;
            }

            int length = 0;

            while (token != BencodingToken.LengthDelimiter)
            {
                length = (10 * length) + (token - '0');

                token = ReadToken();
            }

            if (length > quota)
            {
                throw new InvalidOperationException("Exceeded quota.");
            }

            if (this._peeking)
            {
                throw new InvalidOperationException();
            }

            return this._reader.ReadBytes(length);
        }

        protected override string ReadPrimitiveValueAsString(
            int quota)
        {
            byte[] bytes = ReadPrimitiveValueAsBytes(quota);
            if (null == bytes)
            {
                return null;
            }

            string value = Encoding.UTF8.GetString(bytes, 0, bytes.Length);

            return value;
        }

        protected override MemberValueType PeekValueType()
        {
            MemberValueType memberValueType;

            char token = PeekToken();

            if (token == BencodingToken.Dictionary)
            {
                memberValueType = MemberValueType.Object;
            }
            else if (token == BencodingToken.List)
            {
                memberValueType = MemberValueType.Array;
            }
            else
            {
                memberValueType = MemberValueType.Primitive;
            }

            return memberValueType;
        }

        protected override void SkipPrimitiveValue()
        {
            char token = PeekToken();

            if (token == BencodingToken.Null)
            {
                ReadToken();
            }
            else if (token == BencodingToken.Integer)
            {
                SkipInt();
            }
            else if (char.IsDigit(token))
            {
                // TODO: Skip bytes with a fixed buffer size
                ReadPrimitiveValueAsBytes(1024 * 1024);
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        private void SkipInt()
        {
            char token = ReadToken();
            if (token != BencodingToken.Integer)
            {
                throw new InvalidOperationException();
            }

            do
            {
                token = ReadToken();
                if (token == BencodingToken.End)
                {
                    break;
                }
            }
            while (true);
        }

        private char PeekToken()
        {
            if (!this._peeking)
            {
                this._peekChar = this._reader.ReadChar();
                this._peeking = true;
            }

            return this._peekChar;
        }

        private char ReadToken()
        {
            if (this._peeking)
            {
                this._peeking = false;
                return this._peekChar;
            }

            return this._reader.ReadChar();
        }
    }
}
