#region License
// Copyright (c) 2014, David Taylor
//
// Permission to use, copy, modify, and/or distribute this software for any 
// purpose with or without fee is hereby granted, provided that the above 
// copyright notice and this permission notice appear in all copies, unless 
// such copies are solely in the form of machine-executable object code 
// generated by a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES 
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF 
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR 
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES 
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#endregion License
using System;
using System.Globalization;
using System.IO;
using System.Text;

namespace HotChai.Serialization.Json
{
    public sealed class JsonObjectReader : ObjectReader
    {
        private readonly StreamReader _reader;
        private readonly InspectorStream _stream;
        private readonly StringBuilder _stringBuilder;
        private char _peekChar;
        private bool _peekingChar;

        private static readonly uint[] HexValue = new uint[]
        {
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00 - 0f
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 10 - 1f
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20 - 2f
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, // 30 - 3f
            0, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40 - 4f
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 50 - 5f
            0, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60 - 6f
        };

        public JsonObjectReader(
            Stream stream)
        {
            if (null == stream)
            {
                throw new ArgumentNullException("stream");
            }

            this._stringBuilder = new StringBuilder();
            this._stream = new InspectorStream(stream);
            this._reader = new StreamReader(
                this._stream,
                new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true),
                detectEncodingFromByteOrderMarks: true);
        }

        public override ISerializationInspector Inspector
        {
            get
            {
                return this._stream.Inspector;
            }

            set
            {
                this._stream.Inspector = value;
            }
        }

        protected override bool ReadStartObjectToken()
        {
            var token = ReadToken();
            if (token == JsonToken.StartObject)
            {
                return true;
            }
            else if (token == JsonToken.Null)
            {
                return false;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        protected override bool ReadFirstObjectMemberKey()
        {
            var token = PeekToken();

            if (token == JsonToken.EndObject)
            {
                return false;
            }

            string memberName = ReadString(20, false);
            this.MemberKey = int.Parse(memberName, CultureInfo.InvariantCulture);

            ReadColon();

            SkipWhiteSpace();

            return true;
        }

        protected override bool ReadNextObjectMemberKey()
        {
            var token = PeekToken();

            if (token == JsonToken.EndObject)
            {
                return false;
            }

            ReadComma();

            SkipWhiteSpace();

            string memberName = ReadString(20, false);
            this.MemberKey = int.Parse(memberName, CultureInfo.InvariantCulture);

            ReadColon();

            SkipWhiteSpace();

            return true;
        }

        protected override void ReadEndObjectToken()
        {
            ReadToken(JsonToken.EndObject);
        }

        protected override bool ReadStartArrayToken()
        {
            var token = ReadToken();
            if (token == JsonToken.StartArray)
            {
                return true;
            }
            else if (token == JsonToken.Null)
            {
                return false;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        protected override bool ReadToFirstArrayValue()
        {
            var token = PeekToken();
            if (token == JsonToken.EndArray)
            {
                return false;
            }

            SkipWhiteSpace();

            return true;
        }

        protected override bool ReadToNextArrayValue()
        {
            var token = PeekToken();
            if (token == JsonToken.EndArray)
            {
                return false;
            }

            ReadComma();

            SkipWhiteSpace();

            return true;
        }

        protected override void ReadEndArrayToken()
        {
            ReadToken(JsonToken.EndArray);
        }

        protected override bool ReadPrimitiveValueAsBoolean()
        {
            var token = ReadToken();

            if (token == JsonToken.True)
            {
                return true;
            }
            else if (token == JsonToken.False)
            {
                return false;
            }
            else
            {
                throw new InvalidOperationException("Unexpected Boolean value");
            }
        }

        protected override int ReadPrimitiveValueAsInt32()
        {
            string number = ReadNumber();

            return int.Parse(number, CultureInfo.InvariantCulture);
        }

        protected override uint ReadPrimitiveValueAsUInt32()
        {
            string number = ReadNumber();

            return uint.Parse(number, CultureInfo.InvariantCulture);
        }

        protected override long ReadPrimitiveValueAsInt64()
        {
            string number = ReadNumber();

            return long.Parse(number, CultureInfo.InvariantCulture);
        }

        protected override ulong ReadPrimitiveValueAsUInt64()
        {
            string number = ReadNumber();

            return ulong.Parse(number, CultureInfo.InvariantCulture);
        }

        protected override float ReadPrimitiveValueAsSingle()
        {
            string number = ReadNumber();

            return float.Parse(number, CultureInfo.InvariantCulture);
        }

        protected override double ReadPrimitiveValueAsDouble()
        {
            string number = ReadNumber();

            return double.Parse(number, CultureInfo.InvariantCulture);
        }

        protected override byte[] ReadPrimitiveValueAsBytes(
            int byteQuota)
        {
            // NOTE: Increase quota to account for Base64 expansion
            string base64 = ReadString(byteQuota * 4 / 3 + 2, true);
            if (base64 == null)
            {
                return null;
            }

            return Convert.FromBase64String(base64);
        }

        protected override string ReadPrimitiveValueAsString(
            int byteQuota)
        {
            return ReadString(Encoding.UTF8.GetMaxCharCount(byteQuota), true);
        }

        protected override MemberValueType PeekValueType()
        {
            var token = PeekToken();

            if (token == JsonToken.StartObject)
            {
                return MemberValueType.Object;
            }
            else if (token == JsonToken.StartArray)
            {
                return MemberValueType.Array;
            }

            return MemberValueType.Primitive;
        }

        protected override void SkipPrimitiveValue()
        {
            var token = PeekToken();

            if (token == JsonToken.True)
            {
                ReadToken();
            }
            else if (token == JsonToken.False)
            {
                ReadToken();
            }
            else if (token == JsonToken.Null)
            {
                ReadToken();
            }
            else if (token == JsonToken.String)
            {
                SkipString();
            }
            else
            {
                SkipNumber();
            }
        }

        private void SkipWhiteSpace()
        {
            char c;
            do
            {
                c = PeekChar();
                if (!IsWhiteSpace(c))
                {
                    break;
                }

                ReadChar();
            }
            while (true);
        }

        private bool IsWhiteSpace(char c)
        {
            return ((c == ' ') || (c == '\u0009') || (c == '\u000a') || (c == '\u000d'));
        }

        private bool IsNumeric(char c)
        {
            return (((c >= '0') && (c <= '9')) || (c == '+') || (c == '-') || (c == '.') || (c == 'e') || (c == 'E'));
        }

        private JsonToken ReadToken()
        {
            SkipWhiteSpace();

            JsonToken token;

            char c = ReadChar();

            if (c == '{')
            {
                token = JsonToken.StartObject;
            }
            else if (c == '}')
            {
                token = JsonToken.EndObject;
            }
            else if (c == '[')
            {
                token = JsonToken.StartArray;
            }
            else if (c == ']')
            {
                token = JsonToken.EndArray;
            }
            else if (c == ':')
            {
                token = JsonToken.Colon;
            }
            else if (c == '\"')
            {
                token = JsonToken.String;
            }
            else if (c == ',')
            {
                token = JsonToken.Comma;
            }
            else if (c == 'n')
            {
                // "null"
                ReadChar('u');
                ReadChar('l');
                ReadChar('l');

                token = JsonToken.Null;
            }
            else if (c == 't')
            {
                // "true"
                ReadChar('r');
                ReadChar('u');
                ReadChar('e');

                token = JsonToken.True;
            }
            else if (c == 'f')
            {
                // "false"
                ReadChar('a');
                ReadChar('l');
                ReadChar('s');
                ReadChar('e');

                token = JsonToken.False;
            }
            else
            {
                token = JsonToken.Number;
            }

            return token;
        }

        private void ReadToken(JsonToken token)
        {
            var readToken = ReadToken();
            if (readToken != token)
            {
                throw new InvalidOperationException("Unexpected token");
            }
        }

        private JsonToken PeekToken()
        {
            SkipWhiteSpace();

            JsonToken token;

            char c = PeekChar();

            if (c == '{')
            {
                token = JsonToken.StartObject;
            }
            else if (c == '}')
            {
                token = JsonToken.EndObject;
            }
            else if (c == '[')
            {
                token = JsonToken.StartArray;
            }
            else if (c == ']')
            {
                token = JsonToken.EndArray;
            }
            else if (c == ':')
            {
                token = JsonToken.Colon;
            }
            else if (c == '\"')
            {
                token = JsonToken.String;
            }
            else if (c == ',')
            {
                token = JsonToken.Comma;
            }
            else if (c == 'n')
            {
                token = JsonToken.Null;
            }
            else if (c == 't')
            {
                token = JsonToken.True;
            }
            else if (c == 'f')
            {
                token = JsonToken.False;
            }
            else
            {
                token = JsonToken.Number;
            }

            return token;
        }

        private void ReadColon()
        {
            ReadToken(JsonToken.Colon);
        }

        private void ReadComma()
        {
            ReadToken(JsonToken.Comma);
        }

        private string ReadString(
            int charQuota,
            bool allowNull)
        {
            this._stringBuilder.Length = 0;

            char c = ReadChar();

            if ((allowNull) && (c == 'n'))
            {
                ReadChar('u');
                ReadChar('l');
                ReadChar('l');
                return null;
            }

            // Opening quote
            if (c != '\"')
            {
                throw new InvalidOperationException();
            }

            do
            {
                c = ReadChar();

                if (c == '\"')
                {
                    // Ending double quote

                    break;
                }
                else if (c == '\\')
                {
                    // Escape sequence

                    c = ReadChar();

                    if (c == '\"')
                    {
                        this._stringBuilder.Append('\"');
                    }
                    else if (c == '\'')
                    {
                        this._stringBuilder.Append('\'');
                    }
                    else if (c == '\\')
                    {
                        this._stringBuilder.Append('\\');
                    }
                    else if (c == 'b')
                    {
                        this._stringBuilder.Append((char)0x8);
                    }
                    else if (c == 'f')
                    {
                        this._stringBuilder.Append((char)0xc);
                    }
                    else if (c == 'n')
                    {
                        this._stringBuilder.Append((char)0xa);
                    }
                    else if (c == 'r')
                    {
                        this._stringBuilder.Append((char)0xd);
                    }
                    else if (c == 't')
                    {
                        this._stringBuilder.Append((char)0x9);
                    }
                    else if (c == 'u')
                    {
                        uint hexValue = HexValue[ReadChar()];
                        hexValue += (hexValue * 0x10) + HexValue[ReadChar()];
                        hexValue += (hexValue * 0x10) + HexValue[ReadChar()];
                        hexValue += (hexValue * 0x10) + HexValue[ReadChar()];
                        this._stringBuilder.Append((char)hexValue);
                    }
                    else
                    {
                        throw new InvalidOperationException();
                    }
                }
                else
                {
                    this._stringBuilder.Append(c);
                }
            }
            while (this._stringBuilder.Length < charQuota);

            if (this._stringBuilder.Length >= charQuota)
            {
                throw new InvalidOperationException("Exceeded quota.");
            }

            return this._stringBuilder.ToString();
        }

        private string ReadNumber()
        {
            this._stringBuilder.Length = 0;

            char c;
            do
            {
                c = PeekChar();
                if (!IsNumeric(c))
                {
                    break;
                }

                this._stringBuilder.Append(c);
                ReadChar();
            }
            while (true);

            return this._stringBuilder.ToString();
        }

        private void SkipNumber()
        {
            ReadNumber();
        }

        private void SkipString()
        {
            // TODO: Efficient skipping
            ReadString(1024 * 1024, false);
        }

        private char PeekChar()
        {
            if (!this._peekingChar)
            {
                this._peekChar = (char)this._reader.Read();
                this._peekingChar = true;
            }

            return this._peekChar;
        }

        private char ReadChar()
        {
            if (this._peekingChar)
            {
                this._peekingChar = false;
                return this._peekChar;
            }

            return (char)this._reader.Read();
        }

        private void ReadChar(
            char c)
        {
            if (this.ReadChar() != c)
            {
                throw new Exception("Unexpected character.");
            }
        }
    }
}
